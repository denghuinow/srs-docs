# Detailed Summary

## Background and Scope
Project ZNIX aims to refine traditional information management systems by providing an object-based, application-independent retrieval and manipulation framework. The system focuses on managing information semantics rather than requiring users to master specific software applications. The scope covers the higher-level design of the ZNIX Framework, including centralized information storage, hierarchical organization, and integration with existing applications. Non-goals include multi-user support, networking capabilities, and support for hardware beyond specified constraints.

## Role Matrix and Use Cases
- **End User**: Manages personal information through browser GUI
- **ZNIX-Aware Application**: Uses public API for framework integration
- **ZNIX-Unaware Application**: Interacts via proxy mechanism
- **Framework Services**: Core system daemons managing information

Main scenarios include creating entities from address book contacts, archiving email relationships, and building research project hierarchies. Exception scenarios involve handling archived data access and preventing malicious script access.

## Business Process
**Main Process: Information Capture & Organization (8 steps)**
1. User initiates data capture from supported applications
2. Framework intercepts/retrieves data based on type
3. System creates Entities or Associates based on content
4. Automatically establishes relationships between entities
5. User can modify hierarchy through browser interface
6. User defines custom relationships via relationship GUI
7. Information stored in centralized data store
8. Framework maintains hierarchical organization

**Key Branch: Data Archiving (4 steps)**
- Trigger: User requests archive to removable media
- Archive selected information portions
- Leave residue markers in data store
- Provide archive status during future access attempts

## Domain Model
- **Entity** (ID: unique/required, Type: required, Name, Category)
- **Associate** (ID: unique/required, RelatedEntityID: reference/required, Content)
- **Relationship** (SourceEntityID: reference/required, TargetEntityID: reference/required, Type)
- **Category** (Name: unique/required, Description)
- **Archive** (EntityID: reference/required, StorageLocation: required, ArchiveDate: required)
- **UserSession** (SessionID: unique/required, UserPreferences)
- **Query** (Criteria, Results: reference)
- **StorageMedia** (Type: required, Capacity)

## Interfaces and Integrations
- **Outlook Express**: Inbound → Email capture & entity creation
- **Internet Explorer**: Outbound → Web document archiving
- **Word 2003**: Bidirectional → Document relationship management
- **Address Book**: Inbound → Personnel entity creation
- **Framework API**: Outbound → Entity/relationship manipulation
- **Browser GUI**: Bidirectional → Hierarchy navigation & relationship definition

## Acceptance Criteria
**Given** a user with address book contacts, **when** the framework captures personnel information, **then** entities are created under "People" category.

**Given** an outbound email, **when** intercepted by framework, **then** associates are created and linked to recipient entities.

**Given** archived entity data, **when** user searches for the entity, **then** system indicates archive status and offers remount option.

## Non-functional Metrics
- **Performance**: RAM utilization <40MB, single-user operation only
- **Reliability**: MTBF >3 months
- **Security**: Prevent malicious script access, prevent unintended user corruption
- **Compliance**: Windows 2000 Logo Requirements, Unicode UTF-8/16 standards
- **Observability**: Open source distribution with user feedback mechanisms

## Milestones and Release Strategy
1. Core framework development
2. Proxy mechanism implementation
3. Browser GUI integration
4. API specification completion
5. Third-party application integration
6. Open source release preparation

## Risk List and Mitigation Strategies
- Third-party application compatibility changes → Assume compatibility with specified versions
- Resource constraints on target hardware → Optimize for 256MB RAM systems
- User adoption of new paradigm → Mimic familiar Windows interfaces
- Security vulnerabilities in integrated applications → Rely on application security
- Archive data accessibility → Maintain residue markers with remount capability

## Undecided Issues and Responsible Parties
- Browser integration method (standalone vs Windows Explorer) → UI Design Team
- Specific API similarity to .NET System.IO → Architecture Team
- Complete set of mandatory categories → Product Management
- Developer documentation scope → Documentation Team
- Open source hosting platform selection → Project Management
- Additional storage media support → Future Development
- Multi-user support timeline → Not mentioned
- Networking capabilities roadmap → Not mentioned